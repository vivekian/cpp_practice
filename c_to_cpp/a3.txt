Homework 3: Compute the minimum spanning tree for an inputted graph

Objective

Trees are an important subcategory of graphs. Trees such as binary trees and red-black trees are important data structures used throughout computer science. Again it is hoped that this topic is mostly review for active participants in this class.

This assignment requires the implementation of a minimum spanning tree (MST) algorithm for a weighted undirected graph (Graph). A spanning tree for a Graph g is a tree that reaches all the nodes of the graph. The cost for such a spanning tree is the sum of all the edge costs (weights) in the spanning tree’s edge set. Over all possible spanning trees, the MST is the one with the least total cost (it may not be unique).

Two efficient methods will be explained in this week’s Module, namely Prim’s algorithm and Kruskal’s algorithm. Additionally, the assignment makes the following simplifying assumptions about the unweighted Graph:

Graph is connected. This assumption enables the following invariant: MST invariant states that the edge set for a MST must (i) consist of a set of (V-1) edges and (ii) no edge can create a cycle.
Edge weights may be zero or non-negative. Non-negative edge weights are not a requirement for constructing a MST, but may simplify our implementation.
Edge weights are NOT necessarily different.
Using the forums

Your fellow students are a great resource, and we encourage you to sharpen your ideas against them in the forums. There is a dedicated forum for Programming Homeworks, in which you can post your questions and receive feedback before or after submitting for this assignment. Additionally, make sure to pay attention to weekly posts from the Instructor or TAs, which are intended to spur conversation on topics related to the week's topic.

Honor CodePlease remember that you have agreed to the Honor Code, and your submission should be entirely yours.

Peer Grading

After submitting your work, you will get the opportunity to grade the work of three of your peers on a scale of 0-10. The grade is a sum of several categories and you should offer a brief remark on each category in the 'Overall evaluation/feedback' section. Your own work will also be assessed by your peers, from which we'll get your grade. Since you've worked hard on your submission and would like your peers to do a good job of assessing your work, please take your time and do a good job of assessing your peers' work in return.

Style Guidelinesless 
The following are very thoughtful guidelines recommended by Community TA Mike Roberts and endorsed by the rest of the staff. Keep in mind many IDE’s and programs such as gnu “indent” do some of this automatically.

Everyone gets a few (2 for HW1, 5 for all others) style misstep freebies (typos happen) so do not markdown unless they are consistently inconsistent. Be lenient not rigid. Do comment on style issues you see when you grade them.
Indenting - Must be consistent. Choice of indent size and whether tabs or spaces is used is up to the coder. One exception is that they may or may not like to indent the cases of a switch() and this is OK.
Brace placement - Must be consistent across constructs, i.e. if they do opening brace on same line as a for() they should do the same style for all loops. Functions, classes, structs should use a consistent brace placement, but maybe different from the style used for executable statements.
Comments - Files should have a file header comment (using either /* */ or // is fine). Functions should have a function comment (using either /* */ or // is fine). Other commenting is at the discretion of the coder. If you think they've done too little, too much, or have unclear comments do not dock them points, but do note that in the comment section when you grade them.
Naming - Must be consistent in style, but there are many different named entities and people will be using different styles for different types of entities so be lenient unless they are clearly using two different styles for the same type of entity, i.e. member variables - mX and y aren't consistent, local variables - localVariable and my_counter aren't consistent.
Among useful classics on programming elegantly is the “Taligent’s Guide To Designing Programs” Taligent Press 1994 ISBN 0-201-40888-0. On page 30 they say:” Use comments” Comments aren’t a replacement for reading the code; source code should be as readable as possible. … If source code isn’t completely obvious, include a comment.”

The Google C++ style guide says this:

“Comments

Though a pain to write, comments are absolutely vital to keeping our code readable. The following rules describe what you should comment and where. But remember: while comments are very important, the best code is self-documenting. Giving sensible names to types and variables is much better than using obscure names that you must then explain through comments.

When writing your comments, write for your audience: the next contributor who will need to understand your code. Be generous — the next one may be you!”

http://google-styleguide.googlecode.com/svn/trunk/cppguide.xml

Update your Homework 2 graph class to add two more methods. Add a constructor that can read in a graph from a file. The file format will be an initial integer that is the node size of the graph and the further values will be integer triples: (i, j, cost). See Sample Test Data here.

Implement either the Prim or Kruskal Minimum Spanning Tree Algorithm. These algorithms are similar in flavor to Dijkstra’s shortest path algorithm. Links to these algorithms are provided besides being explained in the videos.

http://en.wikipedia.org/wiki/Kruskal's_algorithm

http://en.wikipedia.org/wiki/Prim_algorithm 

http://en.wikipedia.org/wiki/Minimum_spanning_tree 

The output for MST should be the cost and the tree (the edges).  The input will be provided on the website.

More challenging is an extension to this problem discussed in Module 4 as extra credit, however, for the purpose of this Homework, no extra credit will be given. This is to give each edge one of three colors. Consider that a road may be a local street or a highway or a turnpike.  Many route finding algorithms find a least costly path constrained by what type of road to take. We mimic this with colors and ask that you compute MST where the edge colors are a constraint, eg. all edges must be green. You are welcome to try this problem but the peer grading should be based on the simpler problem where there are no colors.
